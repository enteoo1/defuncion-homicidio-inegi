<!DOCTYPE html>
<meta charset="utf-8">
<title>México - Muertes por defunción - 2022</title>


<style>

.bar {
  fill: steelblue;
}

.bar:hover {
  fill: brown;
}

.title {
  font: bold 14px "Helvetica Neue", Helvetica, Arial, sans-serif;
}
.subtitle {
  font: bold 10px "Helvetica Neue", Helvetica, Arial, sans-serif;
}

.axis {
  font: 10px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {
  display: none;
}

</style>
<body>
<script src="./scripts/d3.v7.min.js"></script> 
<script src="https://unpkg.com/topojson@3"></script>
<script src="https://unpkg.com/d3-simple-slider"></script>

<!--d3.v7.min.js

<script src="http://d3js.org/topojson.v0.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script> 
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script> 
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script> 
-->
<script>  
 
 var margin = {top: 5, right: 5, bottom: 5, left: 5},
     width = 960 - margin.left - margin.right,
     height = 500 - margin.top - margin.bottom;

/*    
var x = d3.scale.ordinal()
    .rangeRoundBands([0, width], .1, .3);

var y = d3.scale.linear()
    .range([height, 0]);   
    
    //console.log(color);
*/
    const path = d3.geoPath();
    
    var x = d3.scaleLinear()
        .domain([0, width])
        .range([0, width]);

    var y = d3.scaleLinear()
        .domain([0, height])
        .range([height, 0]);

    var projection = d3.geoMercator()
        .scale(1200)
        .center([-102.34034978813841, 24.012062015793]);

    var svg = d3.select("body").append("svg")
        .style("border", "1px solid red")
        .attr("width", width)
        .attr("height", height);  

    var g = svg.append("g").attr("id", "stateMap");
    var g1 = svg.append("g").attr("id", "municipalitiesMap");

    var reducedData = null;
    var firstTime = true;
    var slider = null;
    var sliderValue = null;
    
    function reduce_data(deaths_data){
        return new Promise((resolve, reject) => {
            //console.log(deaths_data);
            var results = {states: new Map(), DeathsByYear: new Map()};

            for (var index in deaths_data) {
                //console.log(currentValue);
                var currentValue = deaths_data[index];
                if(!(currentValue)) {
                    //console.log(index);
                }
                if(!(currentValue.IdEstado)) {
                    continue;
                }
                var state = results.states.get(currentValue.IdEstado);

                if(!(state)){
                    state = {};
                    state.IdEstado = currentValue.IdEstado;
                    state.Name = currentValue.Estado;
                    state.DeathsByYear = new Map();
                }

                var theYear = String(currentValue.Año);
                var deathsByYearMap = state.DeathsByYear.get(theYear);

                if(!(deathsByYearMap)){
                    deathsByYearMap = {};
                    deathsByYearMap.Año = parseInt(currentValue.Año);
                    deathsByYearMap.Total = 0;
                    deathsByYearMap.Ratio = 0;
                }

                deathsByYearMap.Total += parseInt(currentValue.Total);

                state.DeathsByYear.set(theYear, deathsByYearMap);
                results.states.set(currentValue.IdEstado, state);

                //
                var totalDeathsByYearMap = results.DeathsByYear.get(theYear);

                if(!(totalDeathsByYearMap)){
                    totalDeathsByYearMap = {};
                    totalDeathsByYearMap.Año = parseInt(currentValue.Año);
                    totalDeathsByYearMap.Total = 0;
                }
                totalDeathsByYearMap.Total += parseInt(currentValue.Total);
                results.DeathsByYear.set(theYear, totalDeathsByYearMap);
            }

            //console.log(results);

            for (const [IdEstado, state] of results.states) {
                //console.log(`${IdEstado} = ${state}`);
                
                for (const [yearKey, item] of state.DeathsByYear) {
                    item.Ratio = item.Total / results.DeathsByYear.get(yearKey).Total;
                }
            }
            //console.log(results);
             
            resolve(results);
        });
    }
    
    function filter_data_by_year(reduced_deaths_data, filter_year) {
        var results = {year: filter_year, states: new Map()};
        var ratioAccum = 0;
        for (const [IdEstado, Estado] of reduced_deaths_data.states) {
            //console.log(`${IdEstado} = ${Estado}`);
            
            state = {};
            state.IdEstado = parseInt(Estado.IdEstado);
            state.Name = Estado.Name;
            state.Deaths = 0;
            state.Ratio = 0;
            
            for (const [yearKey, item] of Estado.DeathsByYear) {
                if(filter_year == yearKey) {
                    state.Deaths = item.Total;
                    //state.Ratio = Math.trunc(item.Ratio * 100);
                    state.Ratio = (item.Ratio * 100);
                    ratioAccum += state.Ratio
                }
            }

            results.states.set(parseInt(Estado.IdEstado), state);            
        } 
        //console.log(ratioAccum);
        //console.log(results);
        return results;
    }
    
    function drawMap(map_data, reduced_deaths_data, yearToFilter) {
        var municipalities_geometries = topojson.feature(map_data, map_data.objects.municipalities);
        var states_geometries = topojson.feature(map_data, map_data.objects.states);
    
        var array  = [];
        var valueMap = new Map();
        for (const [id, state] of reduced_deaths_data.states) {
            valueMap.set(id, state.Ratio);
            array.push(state.Ratio);
        }
        
        var maxRatio = Math.max(...array);
        var color = d3.scaleQuantize([0, maxRatio], d3.schemeYlOrRd[9]);
        var times = d3.utcYears(Date.UTC(1990, 0, 1), Date.UTC(2023, 0, 1))
        
        if(firstTime){
            svg.append("text")
            .attr("class", "title")
            .attr("x", 20)
            .attr("y", 26)
            .text("México - Defunciones por Homicidio 1990 - 2022");
            
             svg.append("text")
            .attr("id", "yearText")
            .attr("class", "title")
            .attr("x", 20)
            .attr("y", 46)
            .text("Año: " + yearToFilter);            
        }

        d3.select("#yearText")
            .text("Año: " + yearToFilter); 
        
        g1.selectAll("path")
        .data(municipalities_geometries.features)
        .join("path")
        .attr("d", path.projection(projection))
        .attr("fill", "transparent")
        .style("stroke", "#333")
        .style("stroke-width", ".2px")
        .attr("class", "muns")
        .attr('transform', () => d3.zoomIdentity 
        .translate(0, 0 ).scale(.92) );
        
        g.selectAll("path")
        .data(states_geometries.features)
        .join("path")
        .attr("d", path.projection(projection))
        .attr("fill", d => color(valueMap.get(d.properties.state_code)))
        .style("stroke", "#333")
        .attr('transform', () => d3.zoomIdentity 
                .translate(0, 0 ).scale(.92) );
        
        if(firstTime) {
            //console.log(Date.UTC(parseInt(yearToFilter), 0, 1));
              slider = d3.sliderBottom()
              .min(d3.min(times))
              .max(d3.max(times))
              .marks(times)
              .width(width-100)
              .tickFormat(d3.utcFormat("%Y"))
              .tickValues(times)
              //.silentValue(()=> Date.UTC(parseInt(yearToFilter), 0, 1))
              //.displayValue(()=> yearToFilter)
              .on('onchange', (val) => {
                    sliderValue = val;
                    
                    var fullYearToFilter = "" + (parseInt(val.getFullYear()) + 1);
                    console.log("yearToFilter: " + yearToFilter);
                    console.log("fullYearToFilter:" + fullYearToFilter);
                    //if(yearToFilter != fullYearToFilter) {
                        filtered_data = filter_data_by_year(reducedData, fullYearToFilter);
                        drawMap(map_data, filtered_data, fullYearToFilter);                      
                    //}

              });

            var gSlider = svg.append("g")
            .style("border", "1px solid red")
            .attr('transform', () => d3.zoomIdentity 
                   .translate(30, height - 40 ).scale(1))
            .attr("x", 20)
            .attr("y", 900)        
            .call(slider);  

        }
        
        if(sliderValue) {
            slider.value(sliderValue);
        }

        
        if(firstTime){
            console.log("Setting firstTime to false");
            firstTime = false;
        }
        
    }
    
    //# load JSON and CSV data
    Promise.all([
        d3.csv('clean.csv'),
        d3.json('mx_tj_pretty.json')
    ]).then(function([deaths_data, map_data]){
      // manipulate data here
        //console.log(deaths_data);
        //console.log(map_data);

        //var reduced_deaths_data = 
        reduce_data(deaths_data)
            .then((reduced_deaths_data)=> {
                console.log(reduced_deaths_data);
				
                reducedData = reduced_deaths_data;
            
                var yearToFilter = "1990";
            
                filtered_data = filter_data_by_year(reduced_deaths_data, yearToFilter);
            
				drawMap(map_data, filtered_data, yearToFilter);
            });
        

    })
    .catch(function(error) {
        // Handle any errors that may occur during data loading
        console.error("Error loading data:", error);
    });       

 
    
    
</script>


</body>